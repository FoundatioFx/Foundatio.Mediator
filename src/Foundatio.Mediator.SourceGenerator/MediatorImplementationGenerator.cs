using System.Text;

namespace Foundatio.Mediator;

internal static class MediatorImplementationGenerator
{
    private static void AddGeneratedFileHeader(StringBuilder source)
    {
        source.AppendLine("// <auto-generated>");
        source.AppendLine("// This file was generated by Foundatio.Mediator source generators.");
        source.AppendLine("// Changes to this file may be lost when the code is regenerated.");
        source.AppendLine("// </auto-generated>");
        source.AppendLine();
        source.AppendLine("using System.Diagnostics;");
        source.AppendLine("using System.Diagnostics.CodeAnalysis;");
        source.AppendLine();
    }

    public static string GenerateMediatorImplementation(List<HandlerInfo> handlers)
    {
        var source = new StringBuilder();

        AddGeneratedFileHeader(source);
        source.AppendLine("#nullable enable");
        source.AppendLine("using System;");
        source.AppendLine("using System.Collections.Generic;");
        source.AppendLine("using System.Linq;");
        source.AppendLine("using System.Threading;");
        source.AppendLine("using System.Threading.Tasks;");
        source.AppendLine("using Microsoft.Extensions.DependencyInjection;");
        source.AppendLine();
        source.AppendLine("namespace Foundatio.Mediator;");
        source.AppendLine();
        source.AppendLine("[ExcludeFromCodeCoverage]");
        source.AppendLine("public class Mediator : IMediator");
        source.AppendLine("{");
        source.AppendLine("    private readonly IServiceProvider _serviceProvider;");
        source.AppendLine();

        // Add caching dictionaries for different invocation types
        source.AppendLine("    // Cache for InvokeAsync without return type: Type -> Func<IMediator, object, CancellationToken, ValueTask>");
        source.AppendLine("    private static readonly System.Collections.Concurrent.ConcurrentDictionary<System.Type, Func<IMediator, object, CancellationToken, ValueTask>> _invokeAsyncCache = new();");
        source.AppendLine();
        source.AppendLine("    // Cache for Invoke without return type: Type -> Func<IMediator, object, CancellationToken, object?>");
        source.AppendLine("    private static readonly System.Collections.Concurrent.ConcurrentDictionary<System.Type, Func<IMediator, object, CancellationToken, object?>> _invokeCache = new();");
        source.AppendLine();
        source.AppendLine("    // Cache for InvokeAsync with return type: (Type, Type) -> Func<IMediator, object, CancellationToken, ValueTask<object?>>");
        source.AppendLine("    private static readonly System.Collections.Concurrent.ConcurrentDictionary<(System.Type MessageType, System.Type ResponseType), Func<IMediator, object, CancellationToken, ValueTask<object?>>> _invokeAsyncWithResponseCache = new();");
        source.AppendLine();
        source.AppendLine("    // Cache for Invoke with return type: (Type, Type) -> Func<IMediator, object, CancellationToken, object?>");
        source.AppendLine("    private static readonly System.Collections.Concurrent.ConcurrentDictionary<(System.Type MessageType, System.Type ResponseType), Func<IMediator, object, CancellationToken, object?>> _invokeWithResponseCache = new();");
        source.AppendLine();

        // Generate constructor
        source.AppendLine("    [DebuggerStepThrough]");
        source.AppendLine("    public Mediator(IServiceProvider serviceProvider)");
        source.AppendLine("    {");
        source.AppendLine("        _serviceProvider = serviceProvider;");
        source.AppendLine("    }");
        source.AppendLine();

        // Expose ServiceProvider for the generated static methods
        source.AppendLine("    public IServiceProvider ServiceProvider => _serviceProvider;");
        source.AppendLine();

        // Helper method to get all applicable handlers for a message type
        source.AppendLine("    [DebuggerStepThrough]");
        source.AppendLine("    private IEnumerable<HandlerRegistration> GetAllApplicableHandlers(object message)");
        source.AppendLine("    {");
        source.AppendLine("        var messageType = message.GetType();");
        source.AppendLine("        var allHandlers = new List<HandlerRegistration>();");
        source.AppendLine();
        source.AppendLine("        // Add handlers for the exact message type");
        source.AppendLine("        var exactHandlers = GetHandlersForType(messageType);");
        source.AppendLine("        allHandlers.AddRange(exactHandlers);");
        source.AppendLine();
        source.AppendLine("        // Add handlers for all implemented interfaces");
        source.AppendLine("        foreach (var interfaceType in messageType.GetInterfaces())");
        source.AppendLine("        {");
        source.AppendLine("            var interfaceHandlers = GetHandlersForType(interfaceType);");
        source.AppendLine("            allHandlers.AddRange(interfaceHandlers);");
        source.AppendLine("        }");
        source.AppendLine();
        source.AppendLine("        // Add handlers for all base classes");
        source.AppendLine("        var currentType = messageType.BaseType;");
        source.AppendLine("        while (currentType != null && currentType != typeof(object))");
        source.AppendLine("        {");
        source.AppendLine("            var baseHandlers = GetHandlersForType(currentType);");
        source.AppendLine("            allHandlers.AddRange(baseHandlers);");
        source.AppendLine("            currentType = currentType.BaseType;");
        source.AppendLine("        }");
        source.AppendLine();
        source.AppendLine("        return allHandlers.Distinct();");
        source.AppendLine("    }");
        source.AppendLine();

        // Helper method to get handlers for a specific type
        source.AppendLine("    [DebuggerStepThrough]");
        source.AppendLine("    private IEnumerable<HandlerRegistration> GetHandlersForType(Type type)");
        source.AppendLine("    {");
        source.AppendLine("        return _serviceProvider.GetKeyedServices<HandlerRegistration>(type.FullName);");
        source.AppendLine("    }");
        source.AppendLine();

        // Generate InvokeAsync method
        source.AppendLine("    public async ValueTask InvokeAsync(object message, CancellationToken cancellationToken = default)");
        source.AppendLine("    {");
        source.AppendLine("        var messageType = message.GetType();");
        source.AppendLine("        var cachedFunc = _invokeAsyncCache.GetOrAdd(messageType, mt =>");
        source.AppendLine("        {");
        source.AppendLine("            var handlers = GetHandlersForType(mt);");
        source.AppendLine("            var handlersList = handlers.ToList();");
        source.AppendLine();
        source.AppendLine("            if (handlersList.Count == 0)");
        source.AppendLine("                throw new InvalidOperationException($\"No handler found for message type {mt.FullName}\");");
        source.AppendLine();
        source.AppendLine("            if (handlersList.Count > 1)");
        source.AppendLine("                throw new InvalidOperationException($\"Multiple handlers found for message type {mt.FullName}. Use PublishAsync for multiple handlers.\");");
        source.AppendLine();
        source.AppendLine("            var handler = handlersList.First();");
        source.AppendLine("            return async (mediator, msg, ct) => await handler.HandleAsync(mediator, msg, ct, null);");
        source.AppendLine("        });");
        source.AppendLine();
        source.AppendLine("        await cachedFunc(this, message, cancellationToken);");
        source.AppendLine("    }");
        source.AppendLine();

        // Generate Invoke method (sync)
        source.AppendLine("    public void Invoke(object message, CancellationToken cancellationToken = default)");
        source.AppendLine("    {");
        source.AppendLine("        var messageType = message.GetType();");
        source.AppendLine("        var cachedFunc = _invokeCache.GetOrAdd(messageType, mt =>");
        source.AppendLine("        {");
        source.AppendLine("            var handlers = GetHandlersForType(mt);");
        source.AppendLine("            var handlersList = handlers.ToList();");
        source.AppendLine();
        source.AppendLine("            if (handlersList.Count == 0)");
        source.AppendLine("                throw new InvalidOperationException($\"No handler found for message type {mt.FullName}\");");
        source.AppendLine();
        source.AppendLine("            if (handlersList.Count > 1)");
        source.AppendLine("                throw new InvalidOperationException($\"Multiple handlers found for message type {mt.FullName}. Use Publish for multiple handlers.\");");
        source.AppendLine();
        source.AppendLine("            var handler = handlersList.First();");
        source.AppendLine("            if (handler.IsAsync)");
        source.AppendLine("                throw new InvalidOperationException($\"Cannot use synchronous Invoke with async-only handler for message type {mt.FullName}. Use InvokeAsync instead.\");");
        source.AppendLine();
        source.AppendLine("            return (mediator, msg, ct) => handler.Handle!(mediator, msg, ct, null);");
        source.AppendLine("        });");
        source.AppendLine();
        source.AppendLine("        cachedFunc(this, message, cancellationToken);");
        source.AppendLine("    }");
        source.AppendLine();

        // Generate InvokeAsync<TResponse> method
        source.AppendLine("    public async ValueTask<TResponse> InvokeAsync<TResponse>(object message, CancellationToken cancellationToken = default)");
        source.AppendLine("    {");
        source.AppendLine("        var messageType = message.GetType();");
        source.AppendLine("        var responseType = typeof(TResponse);");
        source.AppendLine("        var cacheKey = (messageType, responseType);");
        source.AppendLine("        var cachedFunc = _invokeAsyncWithResponseCache.GetOrAdd(cacheKey, key =>");
        source.AppendLine("        {");
        source.AppendLine("            var handlers = GetHandlersForType(key.MessageType);");
        source.AppendLine("            var handlersList = handlers.ToList();");
        source.AppendLine();
        source.AppendLine("            if (handlersList.Count == 0)");
        source.AppendLine("                throw new InvalidOperationException($\"No handler found for message type {key.MessageType.FullName}\");");
        source.AppendLine();
        source.AppendLine("            if (handlersList.Count > 1)");
        source.AppendLine("                throw new InvalidOperationException($\"Multiple handlers found for message type {key.MessageType.FullName}. Use PublishAsync for multiple handlers.\");");
        source.AppendLine();
        source.AppendLine("            var handler = handlersList.First();");
        source.AppendLine("            return async (mediator, msg, ct) => await handler.HandleAsync(mediator, msg, ct, key.ResponseType);");
        source.AppendLine("        });");
        source.AppendLine();
        source.AppendLine("        var result = await cachedFunc(this, message, cancellationToken);");
        source.AppendLine("        return (TResponse)result!;");
        source.AppendLine("    }");
        source.AppendLine();

        // Generate Invoke<TResponse> method (sync)
        source.AppendLine("    public TResponse Invoke<TResponse>(object message, CancellationToken cancellationToken = default)");
        source.AppendLine("    {");
        source.AppendLine("        var messageType = message.GetType();");
        source.AppendLine("        var responseType = typeof(TResponse);");
        source.AppendLine("        var cacheKey = (messageType, responseType);");
        source.AppendLine("        var cachedFunc = _invokeWithResponseCache.GetOrAdd(cacheKey, key =>");
        source.AppendLine("        {");
        source.AppendLine("            var handlers = GetHandlersForType(key.MessageType);");
        source.AppendLine("            var handlersList = handlers.ToList();");
        source.AppendLine();
        source.AppendLine("            if (handlersList.Count == 0)");
        source.AppendLine("                throw new InvalidOperationException($\"No handler found for message type {key.MessageType.FullName}\");");
        source.AppendLine();
        source.AppendLine("            if (handlersList.Count > 1)");
        source.AppendLine("                throw new InvalidOperationException($\"Multiple handlers found for message type {key.MessageType.FullName}. Use Publish for multiple handlers.\");");
        source.AppendLine();
        source.AppendLine("            var handler = handlersList.First();");
        source.AppendLine("            if (handler.IsAsync)");
        source.AppendLine("                throw new InvalidOperationException($\"Cannot use synchronous Invoke with async-only handler for message type {key.MessageType.FullName}. Use InvokeAsync instead.\");");
        source.AppendLine();
        source.AppendLine("            return (mediator, msg, ct) => handler.Handle!(mediator, msg, ct, key.ResponseType);");
        source.AppendLine("        });");
        source.AppendLine();
        source.AppendLine("        var result = cachedFunc(this, message, cancellationToken);");
        source.AppendLine("        return (TResponse)result!;");
        source.AppendLine("    }");
        source.AppendLine();

        // Generate PublishAsync method
        source.AppendLine("    public async ValueTask PublishAsync(object message, CancellationToken cancellationToken = default)");
        source.AppendLine("    {");
        source.AppendLine("        var handlersList = GetAllApplicableHandlers(message).ToList();");
        source.AppendLine();
        source.AppendLine("        // Execute all handlers (zero to many allowed)");
        source.AppendLine("        var tasks = handlersList.Select(h => h.HandleAsync(this, message, cancellationToken, null));");
        source.AppendLine("        await Task.WhenAll(tasks.Select(t => t.AsTask()));");
        source.AppendLine("    }");
        source.AppendLine();

        source.AppendLine("    private static readonly System.Collections.Concurrent.ConcurrentDictionary<System.Type, object> _middlewareCache = new();");
        source.AppendLine("    [DebuggerStepThrough]");
        source.AppendLine("    internal static T GetOrCreateMiddleware<T>(IServiceProvider serviceProvider) where T : class");
        source.AppendLine("    {");
        source.AppendLine("        // Check cache first - if it's there, it means it's not registered in DI");
        source.AppendLine("        if (_middlewareCache.TryGetValue(typeof(T), out var cachedInstance))");
        source.AppendLine("            return (T)cachedInstance;");
        source.AppendLine();
        source.AppendLine("        // Try to get from DI - if registered, always use DI (respects service lifetime)");
        source.AppendLine("        var middlewareFromDI = serviceProvider.GetService<T>();");
        source.AppendLine("        if (middlewareFromDI != null)");
        source.AppendLine("            return middlewareFromDI;");
        source.AppendLine();
        source.AppendLine("        // Not in DI, create and cache our own instance");
        source.AppendLine("        return (T)_middlewareCache.GetOrAdd(typeof(T), type =>");
        source.AppendLine("            ActivatorUtilities.CreateInstance<T>(serviceProvider));");
        source.AppendLine("    }");
        source.AppendLine("}");

        return source.ToString();
    }
}
