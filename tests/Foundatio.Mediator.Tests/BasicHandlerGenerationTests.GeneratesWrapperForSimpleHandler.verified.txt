{
  Diagnostics: null,
  GeneratorDiagnostics: null,
  GeneratedTrees: [
    {
      HintName: _FoundatioModule.cs,
      Source:
// Generated by Foundatio.Mediator v<version>
// Changes to this file may be lost when the code is regenerated.
// </auto-generated>

#nullable enable


using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.DependencyInjection.Extensions;
using System;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Threading;
using System.Threading.Tasks;
using Foundatio.Mediator.Generated;

[assembly: Foundatio.Mediator.FoundatioModule]

namespace Foundatio.Mediator;

[global::System.CodeDom.Compiler.GeneratedCode("Foundatio.Mediator", "<version>")]
[ExcludeFromCodeCoverage]
public static class Tests_MediatorHandlers
{
    public static void AddHandlers(this IServiceCollection services)
    {
        // Register HandlerRegistration instances keyed by message type name

        services.TryAddSingleton<PingHandler>();
        services.AddHandler(new HandlerRegistration(
                MessageTypeKey.Get(typeof(Ping)),
                "PingHandler_Ping_Handler",
                PingHandler_Ping_Handler.UntypedHandleAsync,
                null,
                true));

    }
}

    },
    {
      HintName: _InterceptsLocationAttribute.g.cs,
      Source:
// Generated by Foundatio.Mediator v<version>
// Changes to this file may be lost when the code is regenerated.
// </auto-generated>

#nullable enable

using System;

namespace System.Runtime.CompilerServices;

/// <summary>
/// Indicates that a method is an interceptor and provides the location of the intercepted call.
/// </summary>
[global::System.CodeDom.Compiler.GeneratedCode("Foundatio.Mediator", "<version>")]
[global::System.AttributeUsage(global::System.AttributeTargets.Method, AllowMultiple = true)]
internal sealed class InterceptsLocationAttribute : global::System.Attribute
{
    /// <summary>
    /// Initializes a new instance of the <see cref="InterceptsLocationAttribute"/> class.
    /// </summary>
    /// <param name="version">The version of the location encoding.</param>
    /// <param name="data">The encoded location data.</param>
    public InterceptsLocationAttribute(int version, string data)
    {
        Version = version;
        Data = data;
    }

    /// <summary>
    /// Gets the version of the location encoding.
    /// </summary>
    public int Version { get; }

    /// <summary>
    /// Gets the encoded location data.
    /// </summary>
    public string Data { get; }
}

    },
    {
      HintName: _MediatorHelpers.g.cs,
      Source:
// Generated by Foundatio.Mediator v<version>
// Changes to this file may be lost when the code is regenerated.
// </auto-generated>

#nullable enable

using System;
using System.Diagnostics.CodeAnalysis;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;

namespace Foundatio.Mediator.Generated;

[global::System.CodeDom.Compiler.GeneratedCode("Foundatio.Mediator", "<version>")]
[ExcludeFromCodeCoverage]
internal static class MediatorHelpers
{
    /// <summary>
    /// Converts a Task to ValueTask, avoiding async state machine when already completed.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ValueTask AsValueTask(this Task task)
    {
        if (task.IsCompletedSuccessfully)
            return default;

        return AwaitTask(task);

        static async ValueTask AwaitTask(Task task) => await task.ConfigureAwait(false);
    }

    /// <summary>
    /// Awaits a Task and returns null. Used for UntypedHandleAsync on void handlers.
    /// Avoids async state machine when task is already completed.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ValueTask<object?> AsNullResult(this Task task)
    {
        if (task.IsCompletedSuccessfully)
            return default;

        return AwaitTask(task);

        static async ValueTask<object?> AwaitTask(Task task)
        {
            await task.ConfigureAwait(false);
            return null;
        }
    }

    /// <summary>
    /// Awaits a ValueTask and returns null. Used for UntypedHandleAsync on void handlers.
    /// Avoids async state machine when task is already completed.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ValueTask<object?> AsNullResult(this ValueTask task)
    {
        if (task.IsCompletedSuccessfully)
            return default;

        return AwaitTask(task);

        static async ValueTask<object?> AwaitTask(ValueTask task)
        {
            await task.ConfigureAwait(false);
            return null;
        }
    }

    /// <summary>
    /// Converts a Task{T} to ValueTask{T}, avoiding async state machine when already completed.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ValueTask<T> AsValueTask<T>(this Task<T> task)
    {
        if (task.IsCompletedSuccessfully)
            return new ValueTask<T>(task.Result);

        return AwaitTask(task);

        static async ValueTask<T> AwaitTask(Task<T> task) => await task.ConfigureAwait(false);
    }

    /// <summary>
    /// Converts a ValueTask{T} to ValueTask{T}, avoiding async state machine when already completed.
    /// </summary>
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public static ValueTask<T> AsValueTaskAwaited<T>(this ValueTask<T> task)
    {
        if (task.IsCompletedSuccessfully)
            return new ValueTask<T>(task.Result);

        return AwaitTask(task);

        static async ValueTask<T> AwaitTask(ValueTask<T> task) => await task.ConfigureAwait(false);
    }

    /// <summary>
    /// Publishes cascading messages from a tuple result. The first element matching the response type
    /// is returned; all other non-null elements are published via the mediator.
    /// </summary>
    public static async ValueTask<object?> PublishCascadingMessagesAsync(this IMediator mediator, object? result, Type? responseType)
    {
        if (result == null)
            return null;

        if (result is not ITuple tuple)
            return result;

        object? foundResult = null;

        if (responseType == typeof(object) && tuple.Length > 0)
        {
            foundResult = tuple[0];
            for (int i = 1; i < tuple.Length; i++)
            {
                var item = tuple[i];
                if (item != null)
                    await mediator.PublishAsync(item, CancellationToken.None);
            }

            return foundResult;
        }

        for (int i = 0; i < tuple.Length; i++)
        {
            var item = tuple[i];
            if (item != null && responseType != null && responseType.IsAssignableFrom(item.GetType()))
            {
                foundResult = item;
            }
            else if (item != null)
            {
                await mediator.PublishAsync(item, CancellationToken.None);
            }
        }

        return foundResult;
    }
}

    },
    {
      HintName: PingHandler_Ping_Handler.g.cs,
      Source:
// Generated by Foundatio.Mediator v<version>
// Changes to this file may be lost when the code is regenerated.
// </auto-generated>

#nullable enable

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Diagnostics.CodeAnalysis;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Logging;

namespace Foundatio.Mediator.Generated;

[global::System.CodeDom.Compiler.GeneratedCode("Foundatio.Mediator", "<version>")]
[ExcludeFromCodeCoverage]
public static class PingHandler_Ping_Handler
{
    private static ILogger? _logger;

    public static async System.Threading.Tasks.Task<string> HandleAsync(System.IServiceProvider serviceProvider, Ping message, System.Threading.CancellationToken cancellationToken)
    {
        var logger = _logger ??= serviceProvider.GetService<ILoggerFactory>()?.CreateLogger("PingHandler");
        logger?.LogProcessingMessage("Ping");

        using var activity = MediatorActivitySource.Instance.StartActivity("Ping");
        activity?.SetTag("messaging.system", "Foundatio.Mediator");
        activity?.SetTag("messaging.message.type", "Ping");

        string? handlerResult = default;
        var handlerInstance = GetOrCreateHandler(serviceProvider);
        handlerResult = await handlerInstance.HandleAsync(message, cancellationToken);

        logger?.LogCompletedMessage("Ping");
        activity?.SetStatus(System.Diagnostics.ActivityStatusCode.Ok);
        return handlerResult;
    }

    public static async ValueTask<object?> UntypedHandleAsync(IMediator mediator, object message, CancellationToken cancellationToken, Type? responseType)
    {
        var typedMessage = (Ping)message;
        var result = await HandleAsync((System.IServiceProvider)mediator, typedMessage, cancellationToken);

        if (responseType == null)
        {
            return null;
        }

        return result;
    }

    private static readonly PingHandler _cachedHandler = new();

    [DebuggerStepThrough]
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    private static PingHandler GetOrCreateHandler(IServiceProvider serviceProvider)
    {
        return _cachedHandler;
    }
}

    }
  ]
}
