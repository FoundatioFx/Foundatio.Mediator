using System.Collections.Immutable;
using System.Text.RegularExpressions;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.Diagnostics;

namespace Foundatio.Mediator.Tests;

public abstract class GeneratorTestBase
{
    protected async Task VerifyGenerated(string source, params IIncrementalGenerator[] generators)
    {
        var parseOptions = new CSharpParseOptions(LanguageVersion.Preview);
        var compilation = CreateCompilation(source, parseOptions);

        var sourceGenerators = generators.Select(g => g.AsSourceGenerator());
        GeneratorDriver driver = CSharpGeneratorDriver.Create(sourceGenerators, parseOptions: parseOptions);
        driver = driver.RunGeneratorsAndUpdateCompilation(compilation, out var outputCompilation, out var diagnostics);

        var genResult = driver.GetRunResult();

        await Verify(new
            {
                Diagnostics = diagnostics,
                GeneratorDiagnostics = genResult.Diagnostics,
                GeneratedTrees = genResult.Results
                    .SelectMany(r => r.GeneratedSources)
                    .Select(s => new { s.HintName, Source = s.SourceText.ToString() })
                    .OrderBy(s => s.HintName)
                    .ToList()
            })
            .ScrubLines(l => l.Contains("// <auto-generated>"))
            .AddScrubber(sb =>
            {
                string replaced = Regex.Replace(sb.ToString(),
                    @"GeneratedCode\(""Foundatio\.Mediator"",\s*""[^""]+""\)",
                    "GeneratedCode(\"Foundatio.Mediator\", \"<version>\")");
                sb.Clear().Append(replaced);
            });
    }

    protected (ImmutableArray<Diagnostic> Diagnostics,
        ImmutableArray<Diagnostic> GeneratorDiagnostics,
        IReadOnlyList<(string HintName, string Source)> GeneratedTrees)
        RunGenerator(string source, IIncrementalGenerator[] generators,
            AnalyzerConfigOptionsProvider? optionsProvider = null)
    {
        var parseOptions = new CSharpParseOptions(LanguageVersion.Preview);
        var compilation = CreateCompilation(source, parseOptions);

        var sourceGenerators = generators.Select(g => g.AsSourceGenerator()).ToImmutableArray();
        GeneratorDriver driver = CSharpGeneratorDriver.Create(sourceGenerators, additionalTexts: null,
            parseOptions: parseOptions, optionsProvider: optionsProvider);
        driver = driver.RunGeneratorsAndUpdateCompilation(compilation, out var _, out var diagnostics);

        var genResult = driver.GetRunResult();
        var trees = genResult.Results
            .SelectMany(r => r.GeneratedSources)
            .Select(s => (s.HintName, s.SourceText.ToString()))
            .ToList();

        return (diagnostics, genResult.Diagnostics, trees);
    }

    private static Compilation CreateCompilation(string source, CSharpParseOptions parseOptions)
    {
        return CSharpCompilation.Create(
            assemblyName: "Tests",
            syntaxTrees: [CSharpSyntaxTree.ParseText(source, parseOptions)],
            references:
            [
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(Enumerable).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(Microsoft.Extensions.DependencyInjection.ServiceCollection)
                    .Assembly.Location),
                MetadataReference.CreateFromFile(typeof(IMediator).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(MediatorGenerator).Assembly.Location)
            ],
            options: new CSharpCompilationOptions(OutputKind.DynamicallyLinkedLibrary));
    }

    public static AnalyzerConfigOptionsProvider CreateOptions(params (string Key, string Value)[] globalOptions)
    {
        var dict = globalOptions.ToImmutableDictionary(kv => kv.Key, kv => kv.Value);
        return new SimpleOptionsProvider(dict);
    }

    private sealed class SimpleOptionsProvider : AnalyzerConfigOptionsProvider
    {
        private readonly ImmutableDictionary<string, string> _globals;

        public SimpleOptionsProvider(ImmutableDictionary<string, string> globals)
        {
            _globals = globals;
            GlobalOptions = new SimpleOptions(_globals);
        }

        public override AnalyzerConfigOptions GlobalOptions { get; }
        public override AnalyzerConfigOptions GetOptions(SyntaxTree tree) => new SimpleOptions(_globals);
        public override AnalyzerConfigOptions GetOptions(AdditionalText textFile) => new SimpleOptions(_globals);

        private sealed class SimpleOptions : AnalyzerConfigOptions
        {
            private readonly ImmutableDictionary<string, string> _globals;

            public SimpleOptions(ImmutableDictionary<string, string> globals)
            {
                _globals = globals;
            }

            public override bool TryGetValue(string key, out string value)
            {
                if (_globals.TryGetValue(key, out var v))
                {
                    value = v;
                    return true;
                }
                value = string.Empty;
                return false;
            }
        }
    }
}
